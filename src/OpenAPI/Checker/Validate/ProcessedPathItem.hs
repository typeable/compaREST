{-# OPTIONS_GHC -Wno-orphans #-}
{-# OPTIONS_GHC -Wno-name-shadowing #-}

module OpenAPI.Checker.Validate.ProcessedPathItem
  ( ProcessedPathItem (..)
  , ProcessedPathItems (..)
  , processPathItems
  , Step (..)
  )
where

import Control.Arrow
import Control.Comonad.Env
import Control.Monad
import Data.Foldable as F
import Data.Functor
import Data.HList
import qualified Data.List as L
import Data.Map.Strict as M
import Data.Maybe
import Data.OpenApi
import Data.Text as T
import OpenAPI.Checker.Behavior
import OpenAPI.Checker.Orphans ()
import OpenAPI.Checker.Paths
import OpenAPI.Checker.References
import OpenAPI.Checker.Subtree
import OpenAPI.Checker.Validate.Operation
import OpenAPI.Checker.Validate.PathFragment
import OpenAPI.Checker.Validate.Sums

-- FIXME: There's probably a better name for this, but `PathItem` is already taken ;(
data ProcessedPathItem = ProcessedPathItem
  { path :: FilePath
  , item :: PathItem
  } deriving stock (Eq, Show)

processPathItems :: [(FilePath, PathItem)] -> ProcessedPathItems
processPathItems = ProcessedPathItems . fmap (uncurry ProcessedPathItem)

newtype ProcessedPathItems =
  ProcessedPathItems {unProcessedPathItems :: [ProcessedPathItem]}
  deriving newtype (Eq, Show)

instance Issuable 'APILevel where
  data Issue 'APILevel
    = NoPathsMatched FilePath
    | AllPathsFailed FilePath
    -- When several paths match given but all checks failed
    deriving stock (Eq, Ord, Show)
  issueIsUnsupported _ = False

instance Behavable 'APILevel 'PathLevel where
  data Behave 'APILevel 'PathLevel
    = AtPath (ProdCons FilePath) -- TODO: why are there two?
    deriving stock (Eq, Ord, Show)

instance Subtree ProcessedPathItems where
  type SubtreeLevel ProcessedPathItems = 'APILevel
  type
    CheckEnv ProcessedPathItems =
      '[ ProdCons (Traced (Definitions Param))
       , ProdCons (Traced (Definitions RequestBody))
       , ProdCons (Traced (Definitions SecurityScheme))
       , ProdCons (Traced (Definitions Response))
       , ProdCons (Traced (Definitions Header))
       , ProdCons (Traced (Definitions Schema))
       , ProdCons [Server]
       , ProdCons (Traced (Definitions Link))
       ]
  -- No real way to check it at this level
  checkStructuralCompatibility _ _ = structuralIssue
  checkSemanticCompatibility env beh pc@(ProdCons p c) = do
    -- Each path generated by producer must be handled by consumer with exactly
    -- one way
    for_ (unProcessedPathItems . extract $ p) $ \ prodItem -> do
      let
        prodPath = path prodItem
        matchedItems = do
          consItem <- unProcessedPathItems . extract $ c
          F.toList $ matchingPathItems $ ProdCons prodItem consItem
      case matchedItems of
        [] -> issueAt beh $ NoPathsMatched prodPath
        [match] -> checkCompatibility env (beh >>> step (AtPath $ matchedPath <$> match)) (retraced <$> pc <*> match)
        matches -> anyOfAt beh (AllPathsFailed prodPath) $ do
          match <- matches
          pure $ checkCompatibility env (beh >>> step (AtPath $ matchedPath <$> match)) (retraced <$> pc <*> match)
    where
      retraced pc mpi = traced (ask pc >>> step (MatchedPathStep $ matchedPath mpi)) mpi

-- | Preliminary checks two paths for compatibility.  Returns Nothing if two
-- paths obviously do not match: static parts differ or count of path elements
-- is not equal
matchingPathItems :: ProdCons ProcessedPathItem -> Maybe (ProdCons MatchedPathItem)
matchingPathItems prodCons = do
  let frags = parsePath . path <$> prodCons
  guard $ fragsMatch frags
  let
    mkMatchedItems frag ppi = MatchedPathItem
      { pathItem = item ppi
      , matchedPath = path ppi
      , pathFragments = frag }
  return $ mkMatchedItems <$> frags <*> prodCons

fragsMatch :: ProdCons [PathFragment Text] -> Bool
fragsMatch (ProdCons p c) = maybe False and $ zipAllWith check p c
  where
    check (StaticPath s1) (StaticPath s2) = s1 == s2
    check _ _ = True

zipAllWith :: (a -> b -> c) -> [a] -> [b] -> Maybe [c]
zipAllWith _ [] [] = Just []
zipAllWith f (x : xs) (y : ys) = (f x y :) <$> zipAllWith f xs ys
zipAllWith _ (_ : _) [] = Nothing
zipAllWith _ [] (_ : _) = Nothing

data MatchedPathItem = MatchedPathItem
  { pathItem :: !PathItem
  , matchedPath :: !FilePath
  , pathFragments :: ![PathFragment Text]
  -- ^ Pre-parsed path from PathItem
  } deriving stock (Eq)

tracedParameters :: Traced MatchedPathItem -> [Traced (Referenced Param)]
tracedParameters mpi =
  [ traced (ask mpi >>> step (PathItemParam i)) x
  | (i, x) <- L.zip [0..] $ _pathItemParameters . pathItem $ extract mpi
  ]

-- TODO: simplify?
tracedFragments :: Traced MatchedPathItem -> [Env (Trace PathFragmentParam) (PathFragment Text)]
tracedFragments mpi =
  [ env (ask mpi >>> step (PathFragmentStep i)) x
  | (i, x) <- L.zip [0..] $ pathFragments $ extract mpi
  ]

tracedMethod
  :: OperationMethod
  -> Traced MatchedPathItem
  -> Maybe (Traced' MatchedOperation Operation)
tracedMethod s mpi = env (ask mpi >>> step (OperationMethodStep s)) <$> (pathItemMethod s . pathItem . extract $ mpi)

instance Issuable 'PathLevel where
  data Issue 'PathLevel
    = OperationMissing OperationMethod
    deriving stock (Eq, Ord, Show)
  issueIsUnsupported _ = False

instance Behavable 'PathLevel 'OperationLevel where
  data Behave 'PathLevel 'OperationLevel
    = InOperation OperationMethod
    deriving (Eq, Ord, Show)

instance Subtree MatchedPathItem where
  type SubtreeLevel MatchedPathItem = 'PathLevel
  type CheckEnv MatchedPathItem =
    '[ ProdCons (Traced (Definitions Param))
     , ProdCons (Traced (Definitions RequestBody))
     , ProdCons (Traced (Definitions SecurityScheme))
     , ProdCons (Traced (Definitions Response))
     , ProdCons (Traced (Definitions Header))
     , ProdCons (Traced (Definitions Schema))
     , ProdCons [Server]
     , ProdCons (Traced (Definitions Link))
     ]
  checkStructuralCompatibility _ _ = structuralIssue
  checkSemanticCompatibility env beh prodCons = do
    let
      paramDefs = getH @(ProdCons (Traced (Definitions Param))) env
      pathTracedParams = getPathParams <$> paramDefs <*> prodCons
      getPathParams
        :: Traced (Definitions Param)
        -> Traced MatchedPathItem
        -> [Traced Param]
      getPathParams defs mpi = do
        paramRef <- tracedParameters mpi
        pure $ dereference defs paramRef
      pathTracedFragments = mkPathFragments <$> prodCons
      mkPathFragments mpi operationParams =
        --  operationParams will be known on Operation check stage, so we give a
        --  function, returning fragments
        let
          paramsMap :: Map Text (Traced Param)
          paramsMap = M.fromList $ do
            tracedParam <- operationParams
            let pname = _paramName . extract $ tracedParam
            pure (pname, tracedParam)
          convertFragment = \case
            StaticPath t -> StaticPath t
            DynamicPath pname -> DynamicPath
              $ fromMaybe (error $ "Param not found " <> T.unpack pname)
              $ M.lookup pname paramsMap
        in tracedFragments mpi <&> fmap convertFragment
      operations = getOperations <$> pathTracedParams <*> pathTracedFragments <*> prodCons
      getOperations pathParams getPathFragments mpi = M.fromList $ do
        (name, getOp) <- (id &&& tracedMethod) <$>
          [GetMethod, PutMethod, PostMethod, DeleteMethod, OptionsMethod, HeadMethod, PatchMethod, DeleteMethod]
        operation <- F.toList $ getOp mpi
        -- Got only Justs here
        let retraced = \op -> MatchedOperation { operation = op, pathParams, getPathFragments }
        pure (name, retraced <$> operation)
      check name pc = checkCompatibility @MatchedOperation env (beh >>> step (InOperation name)) pc
    -- Operations are sum-like entities. Use step to operation as key because
    -- why not
    checkSums beh OperationMissing check operations


instance Steppable ProcessedPathItems MatchedPathItem where
  data Step ProcessedPathItems MatchedPathItem = MatchedPathStep FilePath
    deriving (Eq, Ord, Show)

instance Steppable MatchedPathItem MatchedOperation where
  data Step MatchedPathItem MatchedOperation = OperationMethodStep OperationMethod
    deriving (Eq, Ord, Show)

instance Steppable MatchedPathItem (Referenced Param) where
  data Step MatchedPathItem (Referenced Param) = PathItemParam Int
    deriving (Eq, Ord, Show)

instance Steppable MatchedPathItem PathFragmentParam where
  data Step MatchedPathItem PathFragmentParam = PathFragmentStep Int
    deriving (Eq, Ord, Show)
