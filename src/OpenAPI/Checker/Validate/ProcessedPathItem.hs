{-# OPTIONS_GHC -Wno-orphans #-}
{-# OPTIONS_GHC -Wno-name-shadowing #-}

module OpenAPI.Checker.Validate.ProcessedPathItem
  ( ProcessedPathItem (..)
  , ProcessedPathItems (..)
  , processPathItems
  , Step (..)
  )
where

import Control.Comonad.Env
import Control.Monad
import Data.Foldable as F
import Data.Functor
import Data.HList
import qualified Data.List as L
import Data.Map.Strict as M
import Data.Maybe
import Data.OpenApi
import Data.Text as T
import OpenAPI.Checker.References
import OpenAPI.Checker.Subtree
import OpenAPI.Checker.Trace
import OpenAPI.Checker.Validate.Operation
import OpenAPI.Checker.Validate.PathFragment
import OpenAPI.Checker.Validate.Sums

-- FIXME: There's probably a better name for this, but `PathItem` is already taken ;(
data ProcessedPathItem = ProcessedPathItem
  { path :: FilePath
  , item :: PathItem
  }

processPathItems :: [(FilePath, PathItem)] -> ProcessedPathItems
processPathItems = ProcessedPathItems . fmap (uncurry ProcessedPathItem)

newtype ProcessedPathItems =
  ProcessedPathItems {unProcessedPathItems :: [ProcessedPathItem]}

instance Subtree ProcessedPathItems where
  type
    CheckEnv ProcessedPathItems =
      '[ ProdCons (Definitions Param)
       , ProdCons (Definitions RequestBody)
       , ProdCons (Definitions SecurityScheme)
       , ProdCons (Definitions Response)
       , ProdCons (Definitions Header)
       , ProdCons (Definitions Schema)
       , ProdCons [Server]
       ]
  data CheckIssue ProcessedPathItems
    = NoPathsMatched FilePath
    | AllPathsFailed FilePath
    -- When several paths match given but all checks failed
    deriving (Eq, Ord, Show)
  checkCompatibility env pc@(ProdCons p c) = do
    -- Each path generated by producer must be handled by consumer with exactly
    -- one way
    for_ (unProcessedPathItems . extract $ p) $ \ prodItem -> do
      let
        prodPath = path prodItem
        matchedItems = do
          consItem <- unProcessedPathItems . extract $ c
          matched <- F.toList $ matchingPathItems $ ProdCons prodItem consItem
          return matched
      case matchedItems of
        [] -> issueAt p $ NoPathsMatched prodPath
        [match] -> checkCompatibility env (retraced <$> pc <*> match)
        matches -> anyOfAt c (AllPathsFailed prodPath) $ do
          match <- matches
          pure $ checkCompatibility env (retraced <$> pc <*> match)
    where
      retraced pc mpi = traced (ask pc >>> step (MatchedPathStep $ matchedPath mpi)) mpi

-- | Preliminary checks two paths for compatibility.  Returns Nothing if two
-- paths obviously do not match: static parts differ or count of path elements
-- is not equal
matchingPathItems :: ProdCons ProcessedPathItem -> Maybe (ProdCons MatchedPathItem)
matchingPathItems prodCons = do
  let frags = parsePath . path <$> prodCons
  guard $ fragsMatch frags
  let
    mkMatchedItems frag ppi = MatchedPathItem
      { pathItem = item ppi
      , matchedPath = path ppi
      , pathFragments = frag }
  return $ mkMatchedItems <$> frags <*> prodCons

fragsMatch :: ProdCons [PathFragment Text] -> Bool
fragsMatch (ProdCons p c) = maybe False and $ zipAllWith check p c
  where
    check (StaticPath s1) (StaticPath s2) = s1 == s2
    check _ _ = True

zipAllWith :: (a -> b -> c) -> [a] -> [b] -> Maybe [c]
zipAllWith _ [] [] = Just []
zipAllWith f (x : xs) (y : ys) = (f x y :) <$> zipAllWith f xs ys
zipAllWith _ (_ : _) [] = Nothing
zipAllWith _ [] (_ : _) = Nothing

data MatchedPathItem = MatchedPathItem
  { pathItem :: !PathItem
  , matchedPath :: !FilePath
  , pathFragments :: ![PathFragment Text]
  -- ^ Pre-parsed path from PathItem
  }

tracedParameters :: Traced r MatchedPathItem -> [Traced r (Referenced Param)]
tracedParameters mpi =
  [ traced (ask mpi >>> step (PathItemParam i)) x
  | (i, x) <- L.zip [0..] $ _pathItemParameters . pathItem $ extract mpi
  ]

-- TODO: simplify?
tracedFragments :: Traced r MatchedPathItem -> [Env (Trace r PathFragmentParam) (PathFragment Text)]
tracedFragments mpi =
  [ env (ask mpi >>> step (PathFragmentStep i)) x
  | (i, x) <- L.zip [0..] $ pathFragments $ extract mpi
  ]

tracedMethod
  :: OperationMethod
  -> Traced r MatchedPathItem
  -> Maybe (Env (Trace r MatchedOperation) Operation)
tracedMethod s mpi = env (ask mpi >>> step (OperationMethodStep s)) <$> (pathItemMethod s . pathItem . extract $ mpi)

instance Subtree MatchedPathItem where
  type CheckEnv MatchedPathItem =
    '[ ProdCons (Definitions Param)
     , ProdCons (Definitions RequestBody)
     , ProdCons (Definitions SecurityScheme)
     , ProdCons (Definitions Response)
     , ProdCons (Definitions Header)
     , ProdCons (Definitions Schema)
     , ProdCons [Server]
     ]
  data CheckIssue MatchedPathItem
    deriving (Eq, Ord, Show)
  checkCompatibility env prodCons = do
    let
      paramDefs = getH @(ProdCons (Definitions Param)) env
      pathTracedParams = getPathParams <$> paramDefs <*> prodCons
      getPathParams
        :: Definitions Param
        -> Traced r MatchedPathItem
        -> [Traced r Param]
      getPathParams defs mpi = do
        paramRef <- tracedParameters mpi
        pure $ dereference defs paramRef
      pathTracedFragments = mkPathFragments <$> prodCons
      mkPathFragments mpi operationParams =
        --  operationParams will be known on Operation check stage, so we give a
        --  function, returning fragments
        let
          paramsMap :: Map Text (Traced OpenApi Param)
          paramsMap = M.fromList $ do
            tracedParam <- operationParams
            let pname = _paramName . extract $ tracedParam
            pure (pname, tracedParam)
          convertFragment = \case
            StaticPath t -> StaticPath t
            DynamicPath pname -> DynamicPath
              $ fromMaybe (error $ "Param not found " <> T.unpack pname)
              $ M.lookup pname paramsMap
        in tracedFragments mpi <&> fmap convertFragment
      operations = getOperations <$> pathTracedParams <*> pathTracedFragments <*> prodCons
      getOperations pathParams getPathFragments mpi = M.fromList $ do
        (i, getOp) <- (\m -> (m, tracedMethod m)) <$>
          [GetMethod, PutMethod, PostMethod, DeleteMethod, OptionsMethod, HeadMethod, PatchMethod, DeleteMethod]
        operation <- F.toList $ getOp mpi
        -- Got only Justs here
        let retraced = \op -> MatchedOperation { operation = op, pathParams, getPathFragments }
        pure (i, retraced <$> operation)
      check pc = checkCompatibility @MatchedOperation env pc
    -- Operations are sum-like entities. Use step to operation as key because
    -- why not
    checkSums OperationMissing (const check) operations


instance Steppable ProcessedPathItems MatchedPathItem where
  data Step ProcessedPathItems MatchedPathItem = MatchedPathStep FilePath
    deriving (Eq, Ord, Show)

instance Steppable MatchedPathItem MatchedOperation where
  data Step MatchedPathItem MatchedOperation = OperationMethodStep OperationMethod
    deriving (Eq, Ord, Show)

instance Steppable MatchedPathItem (Referenced Param) where
  data Step MatchedPathItem (Referenced Param) = PathItemParam Int
    deriving (Eq, Ord, Show)

instance Steppable MatchedPathItem PathFragmentParam where
  data Step MatchedPathItem PathFragmentParam = PathFragmentStep Int
    deriving (Eq, Ord, Show)
