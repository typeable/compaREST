{-# OPTIONS_GHC -Wno-orphans #-}

module OpenAPI.Checker.Validate.ProcessedPathItem
  ( ProcessedPathItem (..)
  , ProcessedPathItems (..)
  , processPathItems
  , Step (..)
  )
where

import Data.Foldable as F
import Data.HList
import Data.Map.Strict as M
import Data.Maybe
import Data.OpenApi
import Data.Text (Text)
import Generic.Data
import OpenAPI.Checker.References
import OpenAPI.Checker.Subtree
import OpenAPI.Checker.Trace
import OpenAPI.Checker.Validate.Operation
import OpenAPI.Checker.Validate.PathFragment
import OpenAPI.Checker.Validate.Sums

-- FIXME: There's probably a better name for this, but `PathItem` is already taken ;(
data ProcessedPathItem = ProcessedPathItem
  { path :: FilePath
  , item :: PathItem
  }

processPathItems :: [(FilePath, PathItem)] -> ProcessedPathItems
processPathItems = ProcessedPathItems . fmap (uncurry ProcessedPathItem)

newtype ProcessedPathItems = ProcessedPathItems {unProcessedPathItems :: [ProcessedPathItem]}

instance Subtree ProcessedPathItems where
  type
    CheckEnv ProcessedPathItems =
      '[ ProdCons (Definitions Param)
       , ProdCons (Definitions RequestBody)
       , ProdCons (Definitions SecurityScheme)
       , ProdCons (Definitions Response)
       , ProdCons (Definitions Header)
       , ProdCons (Definitions Schema)
       ]
  data CheckIssue ProcessedPathItems
    = NoPathsMatched FilePath
    | TooMuchPathsMatched FilePath Int
    -- ^ Undefined behavior. Maybe we will handle it more smart somehow
    deriving (Eq, Ord, Show)
  issueIsUnsupported = \case
    TooMuchPathsMatched {} -> True
    _                      -> False
  checkCompatibility env (ProdCons p c) = do
    -- Each path generated by producer must be handled by consumer with exactly
    -- one way
    for_ (unProcessedPathItems p) $ \ prodItem -> do
      let
        prodPath = path prodItem
        matchedItems = do
          consItem <- unProcessedPathItems c
          matched <- F.toList $ matchingPathItems $ ProdCons prodItem consItem
          return matched
      case matchedItems of
        [] -> issueAt producer $ NoPathsMatched prodPath
        [matched] -> do
          let
            trace = getTrace <$> matched
            getTrace :: MatchedPathItem -> Trace ProcessedPathItems MatchedPathItem
            getTrace = (error "FIXME: not implemented")
          localTrace trace $ checkCompatibility env matched
        x -> issueAt producer $ TooMuchPathsMatched prodPath $ length x

matchingPathItems :: ProdCons ProcessedPathItem -> Maybe (ProdCons MatchedPathItem)
matchingPathItems = error "FIXME: matchingPathItems not implemented"

data MatchedPathItem = MatchedPathItem
  { pathItem :: PathItem
  }

instance Subtree MatchedPathItem where
  type CheckEnv MatchedPathItem =
    '[ ProdCons (Definitions Param)
     , ProdCons (Definitions RequestBody)
     , ProdCons (Definitions SecurityScheme)
     , ProdCons (Definitions Response)
     , ProdCons (Definitions Header)
     , ProdCons (Definitions Schema)
     ]
  data CheckIssue MatchedPathItem
    = OperationMissing (Step MatchedPathItem MatchedOperation)
    deriving (Eq, Ord, Show)
  checkCompatibility env prodCons = withTrace $ \rootTrace -> do
    let
      check _ pc = checkCompatibility @MatchedOperation env pc
      paramDefs = getH @(ProdCons (Definitions Param)) env
      pathTracedParams = getPathParams <$> rootTrace <*> paramDefs <*> prodCons
      getPathParams
        :: Trace OpenApi MatchedPathItem
        -> Definitions Param
        -> MatchedPathItem
        -> [Traced OpenApi Param]
      getPathParams root defs mpi = do
        paramRef <- _pathItemParameters $ pathItem mpi
        let
          traced = dereferenceTraced defs
            $ Traced (step PathItemParam) paramRef
          res = retrace root traced
        pure res
      operations = getOperations <$> pathTracedParams <*> prodCons
      getOperations pathParams mpi = M.fromList $ do
        (get, s) <-
          [ (_pathItemGet, GetStep)
          , (_pathItemPut, PutStep)
          , (_pathItemPost, PostStep)
          , (_pathItemDelete, DeleteStep)
          , (_pathItemOptions, OptionsStep)
          , (_pathItemHead, HeadStep)
          , (_pathItemPatch, PatchStep)
          , (_pathItemTrace, TraceStep) ]
        operation <- F.toList $ get $ pathItem mpi
        -- Got only Justs here
        let mop = MatchedOperation { operation , pathParams}
            v = Traced (step s) mop
        pure (s, v)
    -- Operations are sum-like entities. Use step to operation as key because
    -- why not
    checkSums OperationMissing check operations

    -- let ProdCons {producer = p, consumer = c} =
    --       (\paramDefs -> fmap (processPathItem paramDefs) . unProcessedPathItems)
    --         <$> getH @(ProdCons (Definitions Param)) env
    --         <*> prodCons
    -- sequenceA_
    --   [ anyOf'
    --     [ localTrace (step <$> ProdCons pSPath cSPath) $ do
    --       -- make sure every path fragment is compatible
    --       sequenceA_
    --         [ localTrace (pure . step $ PathFragmentStep i) $
    --           checkCompatibility
    --           (HCons (ProdCons pPathFragmentParams cPathFragmentParams) env)
    --           pair
    --         | (i, pair) <- zip [0 ..] pathFragments
    --         ]
    --       -- make sure the operation is compatible.
    --       localTrace (pure . step $ getter stepProcessedPathItem) $
    --         checkCompatibility env $ ProdCons pOperation cOperation
    --       pure ()
    --     | (cSPath, cPath, cPathItem) <- c
    --     , -- ... and try to match it with every endpoint in the consumer.
    --     --
    --     -- This is required because the meaning of path fragments can change on
    --     -- a per-method basis even within the same 'PathItem'
    --     --
    --     -- Here we only need to look for the method that the current producer
    --     -- endpoint is using.
    --     (cParams, cOperation) <- maybeToList $ getter cPathItem
    --     , let cPathFragmentParams = retrace (step PathFragmentParentStep) <$> cParams
    --     , -- make sure the paths are the same length
    --     pathFragments <- maybeToList $ zipAllWith ProdCons pPath cPath
    --     ]
    --   | (pSPath, pPath, pPathItem) <- p
    --   , -- look at every endpoint in the producer ...
    --   (ProcessedPathItemGetter getter, (pParams, pOperation)) <-
    --     toList (fmap . (,) <$> processedPathItemGetters <*> pPathItem) >>= maybeToList
    --   , let pPathFragmentParams = retrace (step PathFragmentParentStep) <$> pParams
    --   ]

zipAllWith :: (a -> b -> c) -> [a] -> [b] -> Maybe [c]
zipAllWith _ [] [] = Just []
zipAllWith f (x : xs) (y : ys) = (f x y :) <$> zipAllWith f xs ys
zipAllWith _ (_ : _) [] = Nothing
zipAllWith _ [] (_ : _) = Nothing

-- processPathItem
--   :: Definitions Param -- ^ from components
--   -> ProcessedPathItem
--   -> ( Step ProcessedPathItems PathItem
--      , [PathFragment]
--      , ForeachOperation (Maybe (TracedReferences PathItem Param, Operation))
--      )
-- processPathItem componentParams ProcessedPathItem {path = pathS, item = pathItem} =
--   let path = parsePath pathS
--       commonPathParams =
--         retrace (step PathItemParametersStep)
--           <$> getPathParamRefs componentParams (_pathItemParameters pathItem)
--       processOperation (s :: Step PathItem Operation) op =
--         let operationParams =
--               retrace (Root `Snoc` s `Snoc` OperationParamsStep)
--                 <$> getPathParamRefs componentParams (_operationParameters op)
--             pathParams =
--               operationParams <> commonPathParams
--          in (pathParams, op)
--    in ( PathStep pathS
--       , path
--       , fmap . processOperation
--           <$> stepProcessedPathItem
--           <*> ForeachOperation
--             { processedPathItemGet = _pathItemGet pathItem
--             , processedPathItemPut = _pathItemPut pathItem
--             , processedPathItemPost = _pathItemPost pathItem
--             , processedPathItemDelete = _pathItemDelete pathItem
--             , processedPathItemOptions = _pathItemOptions pathItem
--             , processedPathItemHead = _pathItemHead pathItem
--             , processedPathItemPatch = _pathItemPatch pathItem
--             , processedPathItemTrace = _pathItemTrace pathItem
--             }
--       )

instance Steppable ProcessedPathItems MatchedPathItem where
  data Step ProcessedPathItems MatchedPathItem = MatchedPathStep FilePath
    deriving (Eq, Ord, Show)

instance Steppable MatchedPathItem MatchedOperation where
  data Step MatchedPathItem MatchedOperation
    = GetStep
    | PutStep
    | PostStep
    | DeleteStep
    | OptionsStep
    | HeadStep
    | PatchStep
    | TraceStep
    deriving (Eq, Ord, Show)

instance Steppable MatchedPathItem (Referenced Param) where
  data Step MatchedPathItem (Referenced Param) = PathItemParam
    deriving (Eq, Ord, Show)

-- instance Steppable PathItem PathFragment where
--   data Step PathItem PathFragment
--     = -- | The index of the path item
--       PathFragmentStep Int
--     deriving (Eq, Ord, Show)

-- instance Steppable PathFragment PathItem where
--   data Step PathFragment PathItem = PathFragmentParentStep
--     deriving (Eq, Ord, Show)

-- instance Steppable PathItem (Referenced Param) where
--   data Step PathItem (Referenced Param) = PathItemParametersStep
--     deriving (Eq, Ord, Show)

-- data ForeachOperation a = ForeachOperation
--   { processedPathItemGet :: a
--   , processedPathItemPut :: a
--   , processedPathItemPost :: a
--   , processedPathItemDelete :: a
--   , processedPathItemOptions :: a
--   , processedPathItemHead :: a
--   , processedPathItemPatch :: a
--   , processedPathItemTrace :: a
--   }
--   deriving stock (Functor, Generic1)
--   deriving (Applicative, Foldable) via Generically1 ForeachOperation

-- newtype ProcessedPathItemGetter = ProcessedPathItemGetter (forall a. ForeachOperation a -> a)

-- processedPathItemGetters :: ForeachOperation ProcessedPathItemGetter
-- processedPathItemGetters =
--   ForeachOperation
--     { processedPathItemGet = ProcessedPathItemGetter processedPathItemGet
--     , processedPathItemPut = ProcessedPathItemGetter processedPathItemPut
--     , processedPathItemPost = ProcessedPathItemGetter processedPathItemPost
--     , processedPathItemDelete = ProcessedPathItemGetter processedPathItemDelete
--     , processedPathItemOptions = ProcessedPathItemGetter processedPathItemOptions
--     , processedPathItemHead = ProcessedPathItemGetter processedPathItemHead
--     , processedPathItemPatch = ProcessedPathItemGetter processedPathItemPatch
--     , processedPathItemTrace = ProcessedPathItemGetter processedPathItemTrace
--     }

-- stepProcessedPathItem :: ForeachOperation (Step PathItem Operation)
-- stepProcessedPathItem =
--   ForeachOperation
--     { processedPathItemGet = GetStep
--     , processedPathItemPut = PutStep
--     , processedPathItemPost = PostStep
--     , processedPathItemDelete = DeleteStep
--     , processedPathItemOptions = OptionsStep
--     , processedPathItemHead = HeadStep
--     , processedPathItemPatch = PatchStep
--     , processedPathItemTrace = TraceStep
--     }
